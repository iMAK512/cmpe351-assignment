#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#define MAXIMUM_LINES 1088




struct linkedList{

         int arrivalTime; //Arrival time 
         int waitingTime; //waiting time
         int burstTime; //burst time
         int Name;
         int result; //show result
         int prt; //priority
}

linkedList;

void FirstCome (struct LinkedList Process[]){
      File *Fpntr;
      Fpntr = fopen ("output.txt", "A");
      if (fpntr == NULL)
      {
       printf ("you have Error. ");
       exit(1);
      }

}

struct LinkedList *temp;
temp = (struct LinkedList *) malloc (SIZE *sizeof(struct LinkedList));
int i;
         double AverageWaitTime;
         int TotalWaitTime = 0;
  for (i=0; i<SIZE; i++) {
       temp [i]=process [i];
struct LinkedList list;
int a, b ;
for (a=1; a<SIZE; a++) {
   for (b = 0; b < SIZE - a; b++){
        if (temp[b].aTime > temp[b + 1].atime) {
           list = temp[b];
           temp[b] = temp[b+1];
           temp[b+1] = list;
           }
      }
          
 }

  totalWaitTime = temp [0].wTime = 0;

  for(i = 1; i < SIZE; i++) {
     temp[i].wTime = (temp[i-1].btime + temp[i-1].aTime + temp[i-1].wTime) - temp[i],aTime;
totalWaitTime += temp[i].wTime;

  }

       averageWaitTime = (double)totalWaitTime/SIZE;
             fprintf ()fpntr, "%s" ,  " \n  scheduling method first come first serve \n process wat time : \n");
          for (i=0; i<SIZE; i++)
          {
           fprintf(fpntr, "\nP%d:  %d ms" , i+1, temp[i],wTime);
          }
         fprintf (fpntr, "\n Average wait time : %f ms\n", averageWaitTime);
         printf("%s" , "\n output is stored in the output file ");
         fclose(fpntr);

  } 



void shortestJob ( struct linkedlist process[] )

     {
           File *fptr;
           fptr = fopen("output.txt", "A");
            if (fptr==null) {
                 printf("Error in the file");
                 exit(1);
            }
         Struct LinkedList *temp,list1,list2;
              temp = (struct LinkedList*) malloc(SIZE*sizeof(struct LinkedList));
         int i,a,b;
         int totalWaitTime = 0 ;
         double averageWaitTime;

        for (i=0; i< size; i++){
            temp[i] = proccess[i];
        }
         for (i=0; i< SIZE; i++) {
           for (b=1; b<SIZE; b++){
            if (temp[b]).aTime > tenp[b+1].aTime) {

         
            list2 = temp[b];
            temp[b] = temp[b +1];
            temp[b+1] = list2;
            }
           }
         }

     for (a=2; a<SIZE; a++){
       for (b = 1; b< SIZE - a+1; b++){

         if (temp[b].bTime >temp[b+1].bTime){

          list = temp[b];
          temp[b] = temp[b+1];
          temp[b+1] = list;
         }
       }

      totalWaitTime = temp[0].wTime = 0 ;
     }

       for (i = 1; i< SIZE; i++) {
       temp[i].wTime = (temp[i-1].bTime + temp[i-1].aTime + temp[i-1].wTime) - temp[i].aTime;
       totalWaitTime += temp[i].wTime;

       }

     averageWaitTime = (double)totalWaitTime/SIZE;


     for (a=1;a<SIZE;a++) {

     for (b=0;b<SIZE-a; b++) {
      if (temp[b].Name > temp[b+1].Name){

     list = temp[b];
     temp[b]= temp[b+1];
     temp[b+1] = list;
        }
     }
 }

  fprintf(fpntr, "%s", " scheduling method : shortest job first (non preemptive)\n process Wait Time :");

  for (i=0; i < SIZE; i++){

   fprintf(fpntr,"\np%d: %d ms", i+1, temp [i].wTime);
  }



   fprintf(fpntr, "average wait time is : %f ms " , averageWaitTime);
   printf( "%s" , "output is in the ouput file ");
   
   fclose(fpntr);  
  }
 void Round-Robin (struct LinkedList process[], int quantumTime){

  double averageWaitTime; 
  int i,x; 
  int y=0;
  int currentTime = 0;
  int totalWaitTime = 0; 
  int resumeStatus = 0;
  struct linkedList *temp1, *temp2;
  temp1 = (struct linkedList *) malloc (size *sizeof(struct linkedList));
  temp2 = (struct linkedList *) malloc (size *sizeof(struct linkedList));

  File *fpntr; 
fpntr = fopen ("output.txt", "A");
if (fpntr == NULL){
      printf ("You Have Error");
      exit (1);
}
 for (i=0; i<SIZE; i++)
    temp[i]=process [i];

struct linkedList list;
int a,b;
for (a=1; a<SIZE; a++){
   for (b=a; b<SIZE-a; b++){
     if (temp1[b].aTime > temp1[b + 1].aTime){
      list = temp1[b];
      temp1[b] = temp1[b+1];
      temp1[b+1] = list;
     }
   }
}


  for (i=0; i<SIZE; i++)
    temp2[i] = temp1[i];

  do{
     if (y>SIZE-1){y=0}

    x=0;
    while (x<quantumTime && temp1[y].bTime > 0 ){
       currentTime++;
       x++;
       temp1[y].bTime--;

    }
    if (temp1[y].bTime <= 0 && temp1[y].sr != 1){
       temp1[y].wTime = cuurrentTime - temp2[y].bTime - temp1[y].aTime;
       resumeStatus++;
       temp1[y].sr = 1;
       totalWaitTime = totalWaitTime + temp1 [y].wTime;
       
    }

   y++; 

  } 
 while (resumeStatus <SIZE );

averageWaitTime = (double)totalWaitTime/SIZE;

fprintf (fpntr , "%s" , "scheduling method is : rounding \n process wait time is : ")
fprintf (fpntr , "Average Wait time : %f ", averageWaitTime);
fprintf (fpntr , "scheduling method : first come first serve");

for (i = 0; i<SIZE; i++){
      fprintf (fpntr, "p%d: %d ", i+1, temp[i].wTime);
}
  fprintf (fpntr, "average wait time %f" , averageWaitTime);
  printf ("%s", "rsult is in output file);
  fclose (fpntr);
 }

    int main (int agrc, char **argv)
         {
            struct linkedList *process;
            process = (struct linkedList *) malloc (SIZE*sizeof(struct linkedList));
            int choice,option1,option2,quantumTime;
            int i= 0;
            

       FILE *fp = fopen ("input.txt", "r");


       char line [line_max];
       char *ovalue = NULL;
       unsigned int num[3];

      opterr = 0 ;


     while ((choice = getopt (argc, argv, "f:o:")) != -1)
         switch (choice)
         {
             case 's': 
                if ((fp = fopen(optarg, "r")) == NULL)
                    return 0;

                while (fgets (line, line_max, fp) i== NULL) {
                     scanf(line,"%d:%d:%d:" , &num[0], & num[1], &num[2]);
                     process [i].name = i+1;
                     process[i].bTime = num[0];
                     process[i].aTime = num[1];
                     process[i].p = num[2];
                     i++;
                }
                   fclose (fp);
                   break; 
                   case '0';
                    ovalue = optarg; 
                    fp = fopen(optarg, "w");
                    break; 
                   default ;
               abort();
         }
            printf( "1- non-preemtive mode");
            printf("2- show result");
            printf("3- end program" );
           printf("4 - option" );
          scanf("%d", &option);
          switch (option)

               {
                printf( "1- first come first serve");
                printf ( "2- shortest job first");
                printf ( "3- priority scheduling ");
                 printf ( "4-round robin scheduling");

                case 1: 
                      firstCome(process);
                 break;
                case 2: 
                       
                           shortestJob(process);
                           break ; 
                  case 3: 
                  fp = fopen (ovalue, "r");
                  while (fgets (line, LINE_MAX, fb)){
                     printf(line);
                  }
                    break;

                   case 4: 
                       abort();

                   default : 
                    printf("please select valid option")
                    break;
               }
         } 

             while (option != 5);
         return 0 ;
  }
